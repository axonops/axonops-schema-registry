name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  GO_VERSION: '1.25.5'

jobs:
  # Build binaries and run unit tests
  build:
    name: Build & Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download dependencies
        run: go mod download

      - name: Build server binary
        run: go build -o schema-registry ./cmd/schema-registry

      - name: Build all packages
        run: go build -v ./...

      - name: Run unit tests
        run: go test -v -race -coverprofile=coverage.out ./...

      - name: Build integration test binary
        run: go test -c -tags=integration -o integration.test ./tests/integration/...

      - name: Build concurrency test binary
        run: go test -c -tags=concurrency -o concurrency.test ./tests/concurrency/...

      - name: Build API test binary
        run: go test -c -tags=api -o api.test ./tests/api/...

      - name: Build LDAP test binary
        run: go test -c -tags=ldap -o ldap.test ./tests/integration/...

      - name: Build Vault test binary
        run: go test -c -tags=vault -o vault.test ./tests/integration/...

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.out
          fail_ci_if_error: false

      - name: Upload binaries
        uses: actions/upload-artifact@v4
        with:
          name: test-binaries
          path: |
            schema-registry
            integration.test
            concurrency.test
            api.test
            ldap.test
            vault.test
            tests/integration/testdata/ldap/
          retention-days: 1

  # Static code analysis
  lint:
    name: Static Analysis
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v8
        with:
          version: v2.4.0
          args: --timeout=5m

      - name: go vet
        run: go vet ./...

      - name: Check formatting
        run: |
          if [ -n "$(gofmt -l .)" ]; then
            echo "Code is not formatted. Run 'go fmt ./...'"
            gofmt -d .
            exit 1
          fi

  # Security analysis
  security:
    name: Security Analysis
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install gosec
        run: go install github.com/securego/gosec/v2/cmd/gosec@latest

      - name: Run gosec
        run: gosec -exclude-generated -severity medium ./...

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'

  # Build Docker image
  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [build, lint]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: axonops/schema-registry:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # PostgreSQL tests (integration + concurrency)
  postgres-tests:
    name: PostgreSQL Tests
    runs-on: ubuntu-latest
    needs: [build]
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: schemaregistry
          POSTGRES_PASSWORD: schemaregistry
          POSTGRES_DB: schemaregistry
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Download test binaries
        uses: actions/download-artifact@v4
        with:
          name: test-binaries

      - name: Make binaries executable
        run: chmod +x integration.test concurrency.test

      - name: Wait for PostgreSQL
        run: |
          for i in {1..30}; do
            pg_isready -h localhost -p 5432 -U schemaregistry && break
            sleep 1
          done

      - name: Run integration tests
        env:
          STORAGE_TYPE: postgres
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: schemaregistry
          POSTGRES_PASSWORD: schemaregistry
          POSTGRES_DATABASE: schemaregistry
        run: ./integration.test -test.v -test.timeout=10m

      - name: Run concurrency tests
        env:
          STORAGE_TYPE: postgres
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: schemaregistry
          POSTGRES_PASSWORD: schemaregistry
          POSTGRES_DATABASE: schemaregistry
        run: ./concurrency.test -test.v -test.timeout=15m

  # MySQL tests (integration + concurrency)
  mysql-tests:
    name: MySQL Tests
    runs-on: ubuntu-latest
    needs: [build]
    services:
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_USER: schemaregistry
          MYSQL_PASSWORD: schemaregistry
          MYSQL_DATABASE: schemaregistry
        ports:
          - 3306:3306
        options: >-
          --health-cmd "mysqladmin ping -h localhost"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10

    steps:
      - name: Download test binaries
        uses: actions/download-artifact@v4
        with:
          name: test-binaries

      - name: Make binaries executable
        run: chmod +x integration.test concurrency.test

      - name: Wait for MySQL
        run: |
          for i in {1..30}; do
            mysqladmin ping -h 127.0.0.1 -u root -proot --silent && break
            sleep 2
          done

      - name: Run integration tests
        env:
          STORAGE_TYPE: mysql
          MYSQL_HOST: localhost
          MYSQL_PORT: 3306
          MYSQL_USER: schemaregistry
          MYSQL_PASSWORD: schemaregistry
          MYSQL_DATABASE: schemaregistry
        run: ./integration.test -test.v -test.timeout=10m

      - name: Run concurrency tests
        env:
          STORAGE_TYPE: mysql
          MYSQL_HOST: localhost
          MYSQL_PORT: 3306
          MYSQL_USER: schemaregistry
          MYSQL_PASSWORD: schemaregistry
          MYSQL_DATABASE: schemaregistry
        run: ./concurrency.test -test.v -test.timeout=15m

  # Cassandra tests (integration + concurrency)
  cassandra-tests:
    name: Cassandra Tests
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Download test binaries
        uses: actions/download-artifact@v4
        with:
          name: test-binaries

      - name: Make binaries executable
        run: chmod +x integration.test concurrency.test

      - name: Start Cassandra
        run: |
          # Use host network mode so Cassandra binds to localhost properly
          # Set broadcast addresses to 127.0.0.1 so gocql driver can reconnect
          docker run -d --name cassandra-test \
            --network host \
            -e CASSANDRA_CLUSTER_NAME=TestCluster \
            -e CASSANDRA_DC=dc1 \
            -e CASSANDRA_ENDPOINT_SNITCH=SimpleSnitch \
            -e CASSANDRA_BROADCAST_RPC_ADDRESS=127.0.0.1 \
            -e CASSANDRA_BROADCAST_ADDRESS=127.0.0.1 \
            -e CASSANDRA_LISTEN_ADDRESS=127.0.0.1 \
            -e MAX_HEAP_SIZE=512M \
            -e HEAP_NEWSIZE=100M \
            cassandra:4.1

          # Wait for Cassandra to be ready (up to 5 minutes)
          echo "Waiting for Cassandra to start..."
          for i in {1..90}; do
            if docker exec cassandra-test cqlsh -e "describe cluster" 2>/dev/null; then
              echo "Cassandra is ready"
              break
            fi
            echo "Waiting for Cassandra... ($i)"
            sleep 4
          done

      - name: Create Cassandra keyspace
        run: |
          docker exec cassandra-test cqlsh -e "CREATE KEYSPACE IF NOT EXISTS schemaregistry WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};"

      - name: Wait for Cassandra external connections
        run: |
          echo "Waiting for Cassandra to accept external connections..."
          for i in {1..30}; do
            if timeout 5 bash -c "echo > /dev/tcp/127.0.0.1/9042" 2>/dev/null; then
              echo "Cassandra port 9042 is open"
              # Additional wait for native protocol to be fully ready
              sleep 5
              break
            fi
            echo "Waiting for port 9042... ($i)"
            sleep 2
          done

      - name: Run integration tests
        env:
          STORAGE_TYPE: cassandra
          CASSANDRA_HOSTS: 127.0.0.1
          CASSANDRA_PORT: 9042
          CASSANDRA_KEYSPACE: schemaregistry
        run: ./integration.test -test.v -test.timeout=15m

      - name: Restart Cassandra for concurrency tests
        run: |
          echo "Restarting Cassandra to reset connection state..."
          docker restart cassandra-test

          # Wait for Cassandra to be fully ready again
          echo "Waiting for Cassandra to restart..."
          for i in {1..90}; do
            if docker exec cassandra-test cqlsh -e "SELECT now() FROM system.local" 2>/dev/null; then
              echo "Cassandra is ready"
              break
            fi
            echo "Waiting for Cassandra... ($i)"
            sleep 3
          done

      - name: Run concurrency tests
        env:
          STORAGE_TYPE: cassandra
          CASSANDRA_HOSTS: 127.0.0.1
          CASSANDRA_PORT: 9042
          CASSANDRA_KEYSPACE: schemaregistry
        run: ./concurrency.test -test.v -test.timeout=20m

      - name: Cleanup Cassandra
        if: always()
        run: docker stop cassandra-test && docker rm cassandra-test || true

  # API endpoint tests
  api-tests:
    name: API Endpoint Tests
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Download test binaries
        uses: actions/download-artifact@v4
        with:
          name: test-binaries

      - name: Make binaries executable
        run: chmod +x schema-registry api.test

      - name: Start schema registry (memory backend)
        run: |
          ./schema-registry &
          sleep 3

      - name: Run API tests
        run: ./api.test -test.v -test.timeout=10m

      - name: Stop schema registry
        run: pkill schema-registry || true

  # LDAP authentication tests (uses in-memory storage)
  ldap-tests:
    name: LDAP Auth Tests
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Download test binaries
        uses: actions/download-artifact@v4
        with:
          name: test-binaries

      - name: Make binaries executable
        run: chmod +x ldap.test

      - name: Start OpenLDAP
        run: |
          # Start OpenLDAP container with test configuration
          docker run -d --name openldap-test \
            --network host \
            -e LDAP_ORGANISATION="Example Org" \
            -e LDAP_DOMAIN="example.org" \
            -e LDAP_BASE_DN="dc=example,dc=org" \
            -e LDAP_ADMIN_PASSWORD="adminpassword" \
            -e LDAP_CONFIG_PASSWORD="configpassword" \
            osixia/openldap:1.5.0

          # Wait for OpenLDAP to be ready
          echo "Waiting for OpenLDAP to start..."
          for i in {1..30}; do
            if docker exec openldap-test ldapsearch -x -H ldap://localhost:389 -b "dc=example,dc=org" -D "cn=admin,dc=example,dc=org" -w adminpassword "(objectClass=organization)" 2>/dev/null | grep -q "example"; then
              echo "OpenLDAP is ready"
              break
            fi
            echo "Waiting for OpenLDAP... ($i)"
            sleep 2
          done

      - name: Configure memberOf overlay
        run: |
          # Load memberOf module and configure overlay
          docker exec openldap-test ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/ldap/schema/cosine.ldif 2>/dev/null || true
          docker exec openldap-test ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/ldap/schema/nis.ldif 2>/dev/null || true
          docker exec openldap-test ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/ldap/schema/inetorgperson.ldif 2>/dev/null || true

          # Enable memberOf overlay
          cat > /tmp/memberof.ldif << 'LDIF'
          dn: cn=module,cn=config
          objectClass: olcModuleList
          cn: module
          olcModulePath: /usr/lib/ldap
          olcModuleLoad: memberof.la

          dn: olcOverlay=memberof,olcDatabase={1}mdb,cn=config
          objectClass: olcConfig
          objectClass: olcMemberOf
          objectClass: olcOverlayConfig
          olcOverlay: memberof
          olcMemberOfRefint: TRUE
          olcMemberOfDangling: ignore
          olcMemberOfGroupOC: groupOfNames
          olcMemberOfMemberAD: member
          olcMemberOfMemberOfAD: memberOf
          LDIF

          docker cp /tmp/memberof.ldif openldap-test:/tmp/memberof.ldif
          docker exec openldap-test ldapadd -Y EXTERNAL -H ldapi:/// -f /tmp/memberof.ldif 2>/dev/null || true

      - name: Load test data
        run: |
          # Create organizational units
          cat > /tmp/base.ldif << 'LDIF'
          dn: ou=Users,dc=example,dc=org
          objectClass: organizationalUnit
          ou: Users

          dn: ou=Groups,dc=example,dc=org
          objectClass: organizationalUnit
          ou: Groups
          LDIF

          docker cp /tmp/base.ldif openldap-test:/tmp/base.ldif
          docker exec openldap-test ldapadd -x -H ldap://localhost:389 -D "cn=admin,dc=example,dc=org" -w adminpassword -f /tmp/base.ldif

          # Create users
          cat > /tmp/users.ldif << 'LDIF'
          dn: uid=admin,ou=Users,dc=example,dc=org
          objectClass: inetOrgPerson
          objectClass: posixAccount
          objectClass: shadowAccount
          uid: admin
          cn: Admin User
          sn: User
          givenName: Admin
          mail: admin@example.org
          userPassword: adminpass
          uidNumber: 1000
          gidNumber: 1000
          homeDirectory: /home/admin
          loginShell: /bin/bash

          dn: uid=developer,ou=Users,dc=example,dc=org
          objectClass: inetOrgPerson
          objectClass: posixAccount
          objectClass: shadowAccount
          uid: developer
          cn: Developer User
          sn: User
          givenName: Developer
          mail: developer@example.org
          userPassword: devpass
          uidNumber: 1001
          gidNumber: 1000
          homeDirectory: /home/developer
          loginShell: /bin/bash

          dn: uid=readonly,ou=Users,dc=example,dc=org
          objectClass: inetOrgPerson
          objectClass: posixAccount
          objectClass: shadowAccount
          uid: readonly
          cn: Readonly User
          sn: User
          givenName: Readonly
          mail: readonly@example.org
          userPassword: readonlypass
          uidNumber: 1002
          gidNumber: 1000
          homeDirectory: /home/readonly
          loginShell: /bin/bash

          dn: uid=nogroup,ou=Users,dc=example,dc=org
          objectClass: inetOrgPerson
          objectClass: posixAccount
          objectClass: shadowAccount
          uid: nogroup
          cn: NoGroup User
          sn: User
          givenName: NoGroup
          mail: nogroup@example.org
          userPassword: nogrouppass
          uidNumber: 1003
          gidNumber: 1000
          homeDirectory: /home/nogroup
          loginShell: /bin/bash
          LDIF

          docker cp /tmp/users.ldif openldap-test:/tmp/users.ldif
          docker exec openldap-test ldapadd -x -H ldap://localhost:389 -D "cn=admin,dc=example,dc=org" -w adminpassword -f /tmp/users.ldif

          # Create groups (with memberOf overlay, users will auto-get memberOf attribute)
          cat > /tmp/groups.ldif << 'LDIF'
          dn: cn=SchemaRegistryAdmins,ou=Groups,dc=example,dc=org
          objectClass: groupOfNames
          cn: SchemaRegistryAdmins
          description: Schema Registry Administrators
          member: uid=admin,ou=Users,dc=example,dc=org

          dn: cn=Developers,ou=Groups,dc=example,dc=org
          objectClass: groupOfNames
          cn: Developers
          description: Schema Registry Developers
          member: uid=developer,ou=Users,dc=example,dc=org

          dn: cn=ReadonlyUsers,ou=Groups,dc=example,dc=org
          objectClass: groupOfNames
          cn: ReadonlyUsers
          description: Schema Registry Readonly Users
          member: uid=readonly,ou=Users,dc=example,dc=org
          LDIF

          docker cp /tmp/groups.ldif openldap-test:/tmp/groups.ldif
          docker exec openldap-test ldapadd -x -H ldap://localhost:389 -D "cn=admin,dc=example,dc=org" -w adminpassword -f /tmp/groups.ldif

      - name: Verify LDAP setup
        run: |
          echo "Verifying LDAP users..."
          docker exec openldap-test ldapsearch -x -H ldap://localhost:389 -b "ou=Users,dc=example,dc=org" -D "cn=admin,dc=example,dc=org" -w adminpassword "(objectClass=inetOrgPerson)" uid
          echo "Verifying LDAP groups..."
          docker exec openldap-test ldapsearch -x -H ldap://localhost:389 -b "ou=Groups,dc=example,dc=org" -D "cn=admin,dc=example,dc=org" -w adminpassword "(objectClass=groupOfNames)" cn member
          echo "Verifying memberOf for admin user..."
          docker exec openldap-test ldapsearch -x -H ldap://localhost:389 -b "uid=admin,ou=Users,dc=example,dc=org" -D "cn=admin,dc=example,dc=org" -w adminpassword "(uid=admin)" memberOf || echo "memberOf not available (overlay may not be enabled)"

      - name: Run LDAP tests
        env:
          LDAP_URL: ldap://localhost:389
        run: ./ldap.test -test.v -test.timeout=10m

      - name: Cleanup OpenLDAP
        if: always()
        run: docker stop openldap-test && docker rm openldap-test || true

  # Vault authentication tests (uses in-memory storage for schemas)
  vault-tests:
    name: Vault Auth Tests
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Download test binaries
        uses: actions/download-artifact@v4
        with:
          name: test-binaries

      - name: Make binaries executable
        run: chmod +x vault.test

      - name: Start Vault
        run: |
          # Start Vault in dev mode
          docker run -d --name vault-test \
            --network host \
            -e VAULT_DEV_ROOT_TOKEN_ID=root \
            -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
            hashicorp/vault:1.15

          # Wait for Vault to be ready
          echo "Waiting for Vault to start..."
          for i in {1..30}; do
            if curl -s http://localhost:8200/v1/sys/health | grep -q '"initialized":true'; then
              echo "Vault is ready"
              break
            fi
            echo "Waiting for Vault... ($i)"
            sleep 2
          done

      - name: Configure Vault
        run: |
          # Enable KV v2 secrets engine (already enabled in dev mode as 'secret/')
          # Verify it's working
          curl -s -H "X-Vault-Token: root" http://localhost:8200/v1/sys/mounts | grep -q 'secret/' && echo "KV v2 secrets engine is available"

      - name: Run Vault tests
        env:
          VAULT_ADDR: http://localhost:8200
          VAULT_TOKEN: root
        run: ./vault.test -test.v -test.timeout=10m

      - name: Cleanup Vault
        if: always()
        run: docker stop vault-test && docker rm vault-test || true
