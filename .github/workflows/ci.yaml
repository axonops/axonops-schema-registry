name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  GO_VERSION: '1.23'

jobs:
  # Build and unit tests
  build:
    name: Build & Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download dependencies
        run: go mod download

      - name: Build
        run: go build -v ./...

      - name: Run unit tests
        run: go test -v -race -coverprofile=coverage.out ./...

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.out
          fail_ci_if_error: false

  # Static code analysis
  lint:
    name: Static Analysis
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: v1.64.5
          args: --timeout=5m

      - name: go vet
        run: go vet ./...

      - name: Check formatting
        run: |
          if [ -n "$(gofmt -l .)" ]; then
            echo "Code is not formatted. Run 'go fmt ./...'"
            gofmt -d .
            exit 1
          fi

  # Security analysis
  security:
    name: Security Analysis
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install gosec
        run: go install github.com/securego/gosec/v2/cmd/gosec@latest

      - name: Run gosec
        run: gosec -exclude-generated -severity medium ./...

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'

  # Build Docker image
  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [build, lint]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: axonops/schema-registry:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Integration tests with PostgreSQL
  integration-postgres:
    name: Integration Tests (PostgreSQL)
    runs-on: ubuntu-latest
    needs: [build]
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: schemaregistry
          POSTGRES_PASSWORD: schemaregistry
          POSTGRES_DB: schemaregistry
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Wait for PostgreSQL
        run: |
          for i in {1..30}; do
            pg_isready -h localhost -p 5432 -U schemaregistry && break
            sleep 1
          done

      - name: Run integration tests
        env:
          STORAGE_TYPE: postgres
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: schemaregistry
          POSTGRES_PASSWORD: schemaregistry
          POSTGRES_DATABASE: schemaregistry
        run: go test -v -tags=integration -timeout=10m ./tests/integration/...

  # Integration tests with MySQL
  integration-mysql:
    name: Integration Tests (MySQL)
    runs-on: ubuntu-latest
    needs: [build]
    services:
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_USER: schemaregistry
          MYSQL_PASSWORD: schemaregistry
          MYSQL_DATABASE: schemaregistry
        ports:
          - 3306:3306
        options: >-
          --health-cmd "mysqladmin ping -h localhost"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10

    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Wait for MySQL
        run: |
          for i in {1..30}; do
            mysqladmin ping -h 127.0.0.1 -u root -proot --silent && break
            sleep 2
          done

      - name: Run integration tests
        env:
          STORAGE_TYPE: mysql
          MYSQL_HOST: localhost
          MYSQL_PORT: 3306
          MYSQL_USER: schemaregistry
          MYSQL_PASSWORD: schemaregistry
          MYSQL_DATABASE: schemaregistry
        run: go test -v -tags=integration -timeout=10m ./tests/integration/...

  # Integration tests with Cassandra
  integration-cassandra:
    name: Integration Tests (Cassandra)
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Start Cassandra
        run: |
          # Use host network mode so Cassandra binds to localhost properly
          # Set broadcast addresses to 127.0.0.1 so gocql driver can reconnect
          docker run -d --name cassandra-test \
            --network host \
            -e CASSANDRA_CLUSTER_NAME=TestCluster \
            -e CASSANDRA_DC=dc1 \
            -e CASSANDRA_ENDPOINT_SNITCH=SimpleSnitch \
            -e CASSANDRA_BROADCAST_RPC_ADDRESS=127.0.0.1 \
            -e CASSANDRA_BROADCAST_ADDRESS=127.0.0.1 \
            -e CASSANDRA_LISTEN_ADDRESS=127.0.0.1 \
            -e MAX_HEAP_SIZE=512M \
            -e HEAP_NEWSIZE=100M \
            cassandra:4.1

          # Wait for Cassandra to be ready (up to 5 minutes)
          echo "Waiting for Cassandra to start..."
          for i in {1..90}; do
            if docker exec cassandra-test cqlsh -e "describe cluster" 2>/dev/null; then
              echo "Cassandra is ready"
              break
            fi
            echo "Waiting for Cassandra... ($i)"
            sleep 4
          done

      - name: Create Cassandra keyspace
        run: |
          docker exec cassandra-test cqlsh -e "CREATE KEYSPACE IF NOT EXISTS schemaregistry WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};"

      - name: Debug network - check where port 9042 is listening
        run: |
          echo "=== Port 9042 listeners on host (ss) ==="
          ss -tlnp | grep 9042 || echo "Not found via ss"

          echo ""
          echo "=== Port 9042 listeners on host (netstat) ==="
          netstat -tlnp 2>/dev/null | grep 9042 || echo "Not found via netstat"

          echo ""
          echo "=== Port 9042 inside Cassandra container ==="
          docker exec cassandra-test sh -c "ss -tlnp 2>/dev/null | grep 9042 || netstat -tlnp 2>/dev/null | grep 9042" || echo "Could not check inside container"

          echo ""
          echo "=== Cassandra listen configuration ==="
          docker exec cassandra-test grep -E "^(listen_address|rpc_address|native_transport|broadcast)" /etc/cassandra/cassandra.yaml 2>/dev/null || true

          echo ""
          echo "=== Testing TCP connectivity to 127.0.0.1:9042 ==="
          nc -zv 127.0.0.1 9042 2>&1 || echo "nc failed"
          timeout 5 bash -c 'cat < /dev/null > /dev/tcp/127.0.0.1/9042' 2>&1 && echo "TCP connect succeeded" || echo "TCP connect failed"

          echo ""
          echo "=== Testing TCP connectivity to localhost:9042 ==="
          nc -zv localhost 9042 2>&1 || echo "nc failed"

          echo ""
          echo "=== Docker container info ==="
          docker inspect cassandra-test --format '{{.NetworkSettings.NetworkMode}}' || true
          docker inspect cassandra-test --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' || true

      - name: Run integration tests
        env:
          STORAGE_TYPE: cassandra
          CASSANDRA_HOSTS: 127.0.0.1
          CASSANDRA_PORT: 9042
          CASSANDRA_KEYSPACE: schemaregistry
        run: go test -v -tags=integration -timeout=15m ./tests/integration/...

      - name: Cleanup Cassandra
        if: always()
        run: docker stop cassandra-test && docker rm cassandra-test || true

  # Concurrency tests with multiple instances
  concurrency-postgres:
    name: Concurrency Tests (PostgreSQL)
    runs-on: ubuntu-latest
    needs: [integration-postgres]
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: schemaregistry
          POSTGRES_PASSWORD: schemaregistry
          POSTGRES_DB: schemaregistry
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build binary
        run: go build -o schema-registry ./cmd/schema-registry

      - name: Run concurrency tests
        env:
          STORAGE_TYPE: postgres
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: schemaregistry
          POSTGRES_PASSWORD: schemaregistry
          POSTGRES_DATABASE: schemaregistry
        run: go test -v -tags=concurrency -timeout=15m ./tests/concurrency/...

  concurrency-mysql:
    name: Concurrency Tests (MySQL)
    runs-on: ubuntu-latest
    needs: [integration-mysql]
    services:
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_USER: schemaregistry
          MYSQL_PASSWORD: schemaregistry
          MYSQL_DATABASE: schemaregistry
        ports:
          - 3306:3306
        options: >-
          --health-cmd "mysqladmin ping -h localhost"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10

    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build binary
        run: go build -o schema-registry ./cmd/schema-registry

      - name: Run concurrency tests
        env:
          STORAGE_TYPE: mysql
          MYSQL_HOST: localhost
          MYSQL_PORT: 3306
          MYSQL_USER: schemaregistry
          MYSQL_PASSWORD: schemaregistry
          MYSQL_DATABASE: schemaregistry
        run: go test -v -tags=concurrency -timeout=15m ./tests/concurrency/...

  concurrency-cassandra:
    name: Concurrency Tests (Cassandra)
    runs-on: ubuntu-latest
    needs: [integration-cassandra]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Start Cassandra
        run: |
          # Use host network mode so Cassandra binds to localhost properly
          # Set broadcast addresses to 127.0.0.1 so gocql driver can reconnect
          docker run -d --name cassandra-test \
            --network host \
            -e CASSANDRA_CLUSTER_NAME=TestCluster \
            -e CASSANDRA_DC=dc1 \
            -e CASSANDRA_ENDPOINT_SNITCH=SimpleSnitch \
            -e CASSANDRA_BROADCAST_RPC_ADDRESS=127.0.0.1 \
            -e CASSANDRA_BROADCAST_ADDRESS=127.0.0.1 \
            -e CASSANDRA_LISTEN_ADDRESS=127.0.0.1 \
            -e MAX_HEAP_SIZE=512M \
            -e HEAP_NEWSIZE=100M \
            cassandra:4.1

          # Wait for Cassandra to be ready (up to 5 minutes)
          echo "Waiting for Cassandra to start..."
          for i in {1..90}; do
            if docker exec cassandra-test cqlsh -e "describe cluster" 2>/dev/null; then
              echo "Cassandra is ready"
              break
            fi
            echo "Waiting for Cassandra... ($i)"
            sleep 4
          done

      - name: Create Cassandra keyspace
        run: |
          docker exec cassandra-test cqlsh -e "CREATE KEYSPACE IF NOT EXISTS schemaregistry WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};"

      - name: Build binary
        run: go build -o schema-registry ./cmd/schema-registry

      - name: Run concurrency tests
        env:
          STORAGE_TYPE: cassandra
          CASSANDRA_HOSTS: 127.0.0.1
          CASSANDRA_PORT: 9042
          CASSANDRA_KEYSPACE: schemaregistry
        run: go test -v -tags=concurrency -timeout=20m ./tests/concurrency/...

      - name: Cleanup Cassandra
        if: always()
        run: docker stop cassandra-test && docker rm cassandra-test || true

  # API endpoint tests
  api-tests:
    name: API Endpoint Tests
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build binary
        run: go build -o schema-registry ./cmd/schema-registry

      - name: Start schema registry (memory backend)
        run: |
          ./schema-registry &
          sleep 3

      - name: Run API tests
        run: go test -v -tags=api -timeout=10m ./tests/api/...

      - name: Stop schema registry
        run: pkill schema-registry || true
